= Handling Data Conflicts
:page-aliases:
:page-role:
:keywords: conflict, resolution, replication, sync
:page-layout: article
:description: Couchbase Lite JavaScript -- Handling conflict between data changes

:source-language: javascript

[abstract]
--
Description -- _{description}_ +
Related Content -- xref:replication.adoc[Remote Sync Gateway] | xref:cors-configuration.adoc[CORS Configuration]
--

[#causes-of-conflicts]
== Causes of Conflicts

Document conflicts can occur if multiple changes are made to the same version of a document by multiple peers in a distributed system. For Couchbase Mobile, this can be a Couchbase Lite or Sync Gateway database instance.

Such conflicts can occur after either of the following events:

* *A replication saves a document change* -- in which case the change with the _most-revisions wins_ (unless one change is a delete). See xref:conflict.adoc#lbl-conflicts-when-replicating[Case 1: Conflicts when a replication is in progress]
* *An application saves a document change directly to a database instance* -- in which case, _last write wins_, unless one change is a delete -- see xref:conflict.adoc#conflicts-when-saving[Case 2: Conflicts when saving a document]

NOTE: *_Deletes_ always win.* So, in either of the above cases, if one of the changes was a _Delete_ then that change wins.

The following sections discuss each scenario in more detail.

[TIP]
.Dive deeper ...
Read more about link:https://blog.couchbase.com/document-conflicts-couchbase-mobile[Document Conflicts and Automatic Conflict Resolution in Couchbase Mobile].

[#lbl-conflicts-when-replicating]
== Conflicts when Replicating

There's no practical way to prevent a conflict when incompatible changes to a document are made in multiple instances of an app.
The conflict is realized only when replication propagates the incompatible changes to each other.

.A typical cause of replication conflicts:
[#typical-conflict-scenario]
====
. Alice uses her device to create _DocumentA_.
. Replication syncs _DocumentA_ to Bob's device.
. Alice uses her device to apply _ChangeX_ to _DocumentA_.
. Bob uses his device to make a different change, _ChangeY_, to _DocumentA_.
. Replication syncs _ChangeY_ to Alice's device.
+
This device already has _ChangeX_ putting the local document in conflict.
. Replication syncs _ChangeX_ to Bob's device.
+
This device already has _ChangeY_ and now Bob's local document is in conflict.
====

[#automatic-conflict-resolution]
=== Automatic Conflict Resolution

NOTE: The rules only apply to conflicts caused by replication.
Conflict resolution takes place exclusively during pull replication, while push replication remains unaffected.

Couchbase Lite uses the following rules to handle conflicts such as those described in xref:conflict.adoc#typical-conflict-scenario[]:

* If one of the changes is a deletion:
+
A deleted document (that is, a _tombstone_) always wins over a document update.

* If both changes are document changes:
+
The change with the most revisions wins. If both have the same number of revisions, a deterministic algorithm is used to pick a winner.

The result is saved internally by the Couchbase Lite replicator.
Those rules describe the internal behavior of the replicator.
For additional control over the handling of conflicts, including when a replication is in progress, see xref:conflict.adoc#custom-conflict-resolution[].

[#custom-conflict-resolution]
=== Custom Conflict Resolution

Application developers who want more control over how document conflicts are handled can use custom logic to select the winner between conflicting revisions of a document.

If a custom conflict resolver is not provided, the system will automatically resolve conflicts as discussed in xref:conflict.adoc#automatic-conflict-resolution[].

CAUTION: Custom conflict handlers should be optimized and fast. Time-consuming conflict resolution can slow down the replication process significantly.

To implement custom conflict resolution during replication, you must:

. xref:conflict.adoc#conflict-resolver[Create a Conflict Resolver]
. xref:conflict.adoc#configure-the-replicator[Configure the Replicator]

[#conflict-resolver]
=== Conflict Resolver

Apps have the following strategies for resolving conflicts:

* *Local Wins:* The current revision in the database wins.
* *Remote Wins:* The revision pulled from the remote endpoint through replication wins.
* *Merge:* Merge the content of the conflicting revisions.

.Conflict Resolution Strategies
[#ex-conflict-resolvers]
====

[tabs]
=====

Local Wins::
+
--
[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="local-win-resolver", indent=0]
----
--

Remote Wins::
+
--
[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="remote-win-resolver", indent=0]
----
--

Merge::
+
--
[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="merge-resolver", indent=0]
----
--

Delete::
+
--
[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="delete-resolver", indent=0]
----

When `null` is returned by the resolver, the conflict is resolved as a document deletion.
--

=====

====

[#merge-strategies]
==== Merge Strategies

When implementing a merge strategy, consider these common approaches:

**Property-Level Merge:**

Merge individual properties, giving precedence to non-null or more recent values:

.Property-level merge
[#ex-property-merge]
====
[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="property-merge", indent=0]
----
====

**Field-Specific Rules:**

Apply different rules for different fields:

.Field-specific merge
[#ex-field-specific]
====
[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="field-specific-merge", indent=0]
----
====

**Array Merging:**

Combine arrays from both documents:

.Array merge
[#ex-array-merge]
====
[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="array-merge", indent=0]
----
====

[#configure-the-replicator]
=== Configure the Replicator

The implemented custom conflict resolver is registered on the replicator configuration object.
The default value of the conflictResolver is `null`.
When the value is `null`, the default conflict resolution will be applied.

.Configure Conflict Resolver
[#ex-conflict-resolver-config]
====

[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="conflict-resolver-config", indent=0]
----

====

[#conflicts-when-saving]
== Conflicts when Saving

When updating a document, you need to consider the possibility of update conflicts.
Update conflicts can occur when you try to update a document that's been updated since you read it.

.How Updating May Cause Conflicts
[#update-conflict-scenario]
====
Here's a typical sequence of events that would create an update conflict:

. Your code reads the document's current properties, and constructs a modified copy to save.
. Another thread (perhaps the replicator) updates the document, creating a new revision with different properties.
. Your code updates the document with its modified properties using the save operation.
====

[#automatic-conflict-resolution-2]
=== Automatic Conflict Resolution

In Couchbase Lite, by default, the conflict is automatically resolved and only one document update is stored in the database.
The Last-Write-Win (LWW) algorithm is used to pick the winning update.
So in effect, the changes from step 2 would be overwritten and lost.

If the probability of update conflicts is high in your app and you wish to avoid the possibility of overwritten data, you can use a custom save handler with concurrency control.

[#save-with-conflict-handler]
=== Save with Conflict Handler

Implement a conflict handler when saving documents to handle conflicts during save operations:

.Save with Conflict Handler
[#ex-save-conflict-handler]
====

[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="save-conflict-handler", indent=0]
----

====

The conflict handler receives:

* `document` - The document being saved
* `conflicting` - The current document in the database (that conflicts)

The handler should return:

* The resolved document to save
* `null` to cancel the save operation

[#custom-merge-on-save]
==== Custom Merge on Save

Implement property-level merging when saving:

.Custom merge on save
[#ex-custom-merge-save]
====

[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="custom-merge-save", indent=0]
----

====

[#typescript-conflict-handling]
== TypeScript Support

When using TypeScript, you can type your conflict resolver for better type safety:

.Type-safe conflict resolver
[#ex-typescript-conflict]
====

[source, typescript]
----
include::example$code_snippets/code_snippets.ts[tags="typescript-conflict", indent=0]
----

====

[#conflict-resolution-patterns]
== Common Conflict Resolution Patterns

[#timestamp-based]
=== Timestamp-Based Resolution

Use timestamps to determine which change is newer:

.Timestamp-based resolution
[#ex-timestamp-resolution]
====

[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="timestamp-resolution", indent=0]
----

====

[#priority-based]
=== Priority-Based Resolution

Give priority to certain document states:

.Priority-based resolution
[#ex-priority-resolution]
====

[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="priority-resolution", indent=0]
----

====

[#user-based]
=== User-Based Resolution

Let users decide how to resolve conflicts:

.User-prompted resolution
[#ex-user-resolution]
====

[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="user-resolution", indent=0]
----

====

[#testing-conflict-resolution]
== Testing Conflict Resolution

Test your conflict resolution logic thoroughly:

.Test conflict scenarios
[#ex-test-conflicts]
====

[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="test-conflicts", indent=0]
----

====

[#monitoring-conflicts]
== Monitoring Conflicts

Monitor conflicts during replication:

.Monitor conflicts
[#ex-monitor-conflicts]
====

[source, javascript]
----
include::example$code_snippets/code_snippets.ts[tags="monitor-conflicts", indent=0]
----

====


[#related-content]
== Related Content
++++
<div class="card-row three-column-row">
++++

[.column]
=== {empty}
.How to . . .
* xref:gs-prereqs.adoc[Prerequisites]
* xref:gs-install.adoc[Install]

.

[.column]
=== {empty}
.Learn more . . .
* xref:replication.adoc[Remote Sync Gateway]
* xref:cors-configuration.adoc[CORS Configuration]
* xref:database.adoc[Databases]
* xref:document.adoc[Documents]

.

[.column]
=== {empty}
.Dive Deeper . . .
https://forums.couchbase.com/c/mobile/14[Mobile Forum] |
https://blog.couchbase.com/[Blog] |
https://docs.couchbase.com/tutorials/[Tutorials]

.

++++
</div>
++++